---
title: 🎨 常用数据结构
summary: 使用到的数据结构汇总
date: 2025-08-05
authors:
  - admin
tags:
  - 计算机基础
  - 数据结构
  - LeetCode
---
# 常用数据结构

## 概述
记载LeetCode上解题使用的一些数据结构

## 二叉树

### 1. 遍历
#### 中序遍历（左→根→右）
- 核心逻辑：先访问当前根节点，再递归/迭代遍历左子树，最后遍历右子树
  ```java
  public void dfs(TreeNode root) {
        if (root != null) {
            // 1
            dfs(root.left);
            // 2
            result.add(root.val);
            // 3
            dfs(root.right);
        }
    }
  ```
  调整123位置即可变为前序（213）后序遍历（132）

#### 1.4 层序遍历（按层访问）
- 核心逻辑：基于队列实现“先进先出”，按层处理节点（先处理当前层所有节点，再入队下一层节点）
- 迭代实现（Java，借助队列）：
  ```java
  public List<List<Integer>> levelOrder(TreeNode root) {
      List<List<Integer>> res = new ArrayList<>();
      if (root == null) {
          return res;
      }
      Queue<TreeNode> queue = new LinkedList<>();
      queue.offer(root);  // 根节点入队

      while (!queue.isEmpty()) {
          int levelSize = queue.size();  // 当前层节点数量（关键：避免混入下一层节点）
          List<Integer> levelRes = new ArrayList<>();

          // 处理当前层所有节点
          for (int i = 0; i < levelSize; i++) {
              TreeNode node = queue.poll();
              levelRes.add(node.val);

              // 下一层节点入队（左→右）
              if (node.left != null) {
                  queue.offer(node.left);
              }
              if (node.right != null) {
                  queue.offer(node.right);
              }
          }
          res.add(levelRes);  // 加入当前层结果
      }
      return res;
  }
  ```
- 复杂度：时间O(n)，空间O(n)（队列最大容量为叶子节点数，最坏为n/2）
- 典型例题：LeetCode 102. 二叉树的层序遍历

### 2. 前驱与后继（二叉搜索树BST特有）
前驱/后继是BST的核心概念（中序遍历为有序序列，前驱是前一个元素，后继是后一个元素），常用于BST的删除操作（删除节点后用前驱/后继补位）。

#### 2.1 前驱节点（比当前节点小的最大节点）
- 核心逻辑：
  1. 若当前节点有左子树：前驱是左子树的“最右节点”（左子树最大值）；
  2. 若当前节点无左子树：向上回溯父节点，直到找到“当前节点是父节点右子树”的父节点（该父节点即为前驱）。
- Java代码模板（假设节点含父指针`parent`）：
  ```java
  public TreeNode findPredecessor(TreeNode node) {
      if (node == null) {
          return null;
      }
      // 情况1：有左子树，找左子树最右节点
      if (node.left != null) {
          node = node.left;
          while (node.right != null) {
              node = node.right;
          }
          return node;
      }
      // 情况2：无左子树，回溯父节点
      while (node.parent != null && node == node.parent.left) {
          node = node.parent;  // 当前节点是父节点的左子树，继续回溯
      }
      return node.parent;  // 找到“当前节点是父节点右子树”的父节点
  }
  ```

#### 2.2 后继节点（比当前节点大的最小节点）
- 核心逻辑：
  1. 若当前节点有右子树：后继是右子树的“最左节点”（右子树最小值）；
  2. 若当前节点无右子树：向上回溯父节点，直到找到“当前节点是父节点左子树”的父节点（该父节点即为后继）。
- Java代码模板（假设节点含父指针`parent`）：
  ```java
  public TreeNode findSuccessor(TreeNode node) {
      if (node == null) {
          return null;
      }
      // 情况1：有右子树，找右子树最左节点
      if (node.right != null) {
          node = node.right;
          while (node.left != null) {
              node = node.left;
          }
          return node;
      }
      // 情况2：无右子树，回溯父节点
      while (node.parent != null && node == node.parent.right) {
          node = node.parent;  // 当前节点是父节点的右子树，继续回溯
      }
      return node.parent;  // 找到“当前节点是父节点左子树”的父节点
  }
  ```
- 典型例题：LeetCode 285. 二叉搜索树中的中序后继

### 3. 2-3-4树到红黑树（平衡树转换）
红黑树是“平衡二叉搜索树”的一种，本质是“2-3-4树的二叉表示”，通过颜色规则保证树高为O(log n)，避免BST退化为链表（如顺序插入时）。

#### 3.1 2-3-4树基础
2-3-4 树是一种 **多路平衡查找树**（属于 B 树的特例，阶数为 4），其核心特性是 **所有叶子节点始终在同一层**，这一特性通过严格的插入、分裂、删除、合并规则实现，从而保证树在动态操作（增删元素）后仍能维持平衡。要理解其平衡生长机制，需先明确 2-3-4 树的节点结构，再拆解插入、删除过程中的关键操作逻辑。

##### 2-3-4 树的节点结构
2-3-4 树的节点分为三类，节点的“类型”由其包含的 **关键字数量** 决定，且每个节点的子节点数始终比关键字数多 1（遵循 B 树的核心规则）。节点的关键字按 **升序排列**，子节点的范围严格对应关键字划分的区间，这是查找和维护平衡的前提。

- **2-节点**：包含 1 个关键字，对应 2 个子节点（左子树、右子树）
  - 左子树中所有元素 < 该关键字；右子树中所有元素 > 该关键字。
- **3-节点**：包含 2 个关键字（k1 < k2），对应 3 个子节点（左、中、右）
  - 左子树元素 < k1；中间子树元素 ∈ (k1, k2)；右子树元素 > k2。
- **4-节点**：包含 3 个关键字（k1 < k2 < k3），对应 4 个子节点（左、左中、右中、右）
  - 左子树元素 < k1；左中树元素 ∈ (k1, k2)；右中树元素 ∈ (k2, k3)；右子树元素 > k3。

**核心约束**：所有节点的关键字数量只能是 1、2、3（即节点只能是 2/3/4-节点），不允许出现“关键字数为 0”的空节点或“关键字数 ≥4”的溢出节点——这一约束通过“分裂”和“合并”操作严格保证，是平衡生长的关键。


##### 插入：通过“预分裂”避免失衡
2-3-4 树的插入逻辑核心是 **“不允许节点在插入后溢出”**（即插入后关键字数不能超过 3）。因此，插入前会先检查路径上的节点是否为 4-节点，若为 4-节点则先分裂，再继续向下插入，最终保证所有叶子在同一层。

###### 插入的前提：从根到叶子的“预分裂”
插入操作始终从 **根节点** 开始，沿查找路径（寻找元素应插入的叶子节点位置）向下遍历，遍历过程中执行“预分裂”：
- 若当前节点是 **4-节点**（含 3 个关键字），则先将其分裂为 3 个 2-节点，再继续向下；
- 若当前节点是 **2/3-节点**（含 1/2 个关键字），则直接向下，直至到达目标叶子节点。

###### 节点的分裂规则
分裂是 2-3-4 树维持平衡的关键操作，分裂后不会改变树的高度（或仅在根节点分裂时增加一层，但所有叶子仍在同一层）。具体步骤如下（假设 4-节点关键字为 k1 < k2 < k3）：
1. **提取中间关键字 k2**：k2 会成为新的“父节点”（或并入上层父节点）；
2. **分裂为 3 个 2-节点**：
   - 左子节点：仅含 k1，继承原 4-节点的前 2 个子节点（左、左中）；
   - 中间子节点：仅含 k2（新父节点），左孩子是上述左子节点，右孩子是下述右子节点；
   - 右子节点：仅含 k3，继承原 4-节点的后 2 个子节点（右中、右）；
3. **处理父节点**：
   - 若分裂的是 **非根节点**：将中间关键字 k2 插入到其父节点中（父节点此时是 2/3-节点，插入后变为 3/4-节点，不会溢出）；
   - 若分裂的是 **根节点**：中间关键字 k2 成为新的根节点，树的高度增加 1（但所有叶子仍在同一层，因分裂仅向上扩展一层，不影响叶子深度）。

### 3. 叶子节点的插入
当遍历到目标叶子节点时（此时叶子节点必为 2/3-节点，因已预分裂），直接插入元素：
- 若叶子是 2-节点（1 个关键字）：插入后变为 3-节点（2 个关键字），无溢出；
- 若叶子是 3-节点（2 个关键字）：插入后变为 4-节点？不——因插入前已预分裂路径上的 4-节点，目标叶子必为 2/3-节点，插入后最多为 3-节点（如 3-节点插入后变为 4-节点？此处需修正：预分裂确保“到达叶子时，叶子是 2/3-节点，插入后若变为 4-节点，需立即分裂？不，预分裂的逻辑是“路径上的节点先分裂，叶子节点插入后不会溢出”——实际是“查找路径上的节点若为 4-节点则先分裂，因此到达叶子时，叶子必为 2/3-节点，插入后最多 3 个关键字，无需再分裂”）。

### 4. 插入示例（直观理解平衡）
假设初始树是一个 4-节点（根节点，关键字 20,30,40），现在插入 25：
1. 根节点是 4-节点，先分裂：
   - 提取中间关键字 30 作为新根节点（2-节点）；
   - 左子节点：含 20，无后代；
   - 右子节点：含 40，无后代；
2. 插入 25：沿根节点 30 向下，25 < 30，进入左子节点（2-节点，含 20）；
3. 左子节点是 2-节点，插入 25 后变为 3-节点（20,25），无溢出；
4. 最终树的叶子节点（20,25）和（40）在同一层，维持平衡。

## 四、平衡生长的本质：操作前“修正异常节点”
2-3-4 树之所以能保证平衡，核心在于 **“所有动态操作（插入/删除）前，先修正路径上的异常节点（4-节点/2-节点）”**，避免操作后出现溢出或下溢，最终确保：
1. **节点关键字数合法**：始终为 1、2、3（无溢出 4-节点，无下溢 1-节点）；
2. **叶子深度一致**：插入时仅根分裂会增加高度，且所有叶子同步下移；删除时仅根合并会减少高度，且所有叶子同步上移，始终保持在同一层。

这种“预处理”机制从根本上避免了像二叉搜索树那样因单侧插入/删除导致的失衡，是 2-3-4 树作为平衡查找树的核心设计。

#### 3.2 红黑树与2-3-4树的映射
红黑树用“二叉节点+颜色”模拟2-3-4树，颜色规则对应：
- 红黑树核心规则：
  1. 根节点为黑色；
  2. 叶子节点（NIL节点，空节点）为黑色；
  3. 红节点的父节点必为黑色（无连续红节点）；
  4. 任意节点到其所有叶子节点的路径中，黑色节点数相同（黑高一致）；
  5. 新插入节点默认为红色（减少调整次数）。
- 映射关系：
  - 2-节点 → 黑色节点（无红子节点）；
  - 3-节点 → 黑色父节点+红色左子节点（左倾红黑树，简化实现）；
  - 4-节点 → 黑色父节点+红色左子节点+红色右子节点。

#### 3.3 红黑树关键操作（插入后调整）
插入新节点后可能破坏红黑规则，需通过“颜色翻转”“旋转（左旋/右旋）”修复：
- 左旋操作（Java代码模板）：
  ```java
  // 左旋节点x（x的右子节点y非空）
  private void leftRotate(TreeNode x) {
      TreeNode y = x.right;  // y是x的右子节点
      x.right = y.left;      // y的左子树变为x的右子树
      if (y.left != null) {
          y.left.parent = x; // 更新y左子树的父节点
      }
      y.parent = x.parent;   // 更新y的父节点（原x的父节点）
      if (x.parent == null) {
          root = y;          // 若x是根节点，y成为新根
      } else if (x == x.parent.left) {
          x.parent.left = y; // 若x是左子树，y成为新左子树
      } else {
          x.parent.right = y;// 若x是右子树，y成为新右子树
      }
      y.left = x;            // x成为y的左子节点
      x.parent = y;          // 更新x的父节点为y
  }
  ```
- 右旋操作（Java代码模板）：
  ```java
  // 右旋节点y（y的左子节点x非空）
  private void rightRotate(TreeNode y) {
      TreeNode x = y.left;   // x是y的左子节点
      y.left = x.right;      // x的右子树变为y的左子树
      if (x.right != null) {
          x.right.parent = y; // 更新x右子树的父节点
      }
      x.parent = y.parent;   // 更新x的父节点（原y的父节点）
      if (y.parent == null) {
          root = x;          // 若y是根节点，x成为新根
      } else if (y == y.parent.right) {
          y.parent.right = x;// 若y是右子树，x成为新右子树
      } else {
          y.parent.left = x; // 若y是左子树，x成为新左子树
      }
      x.right = y;           // y成为x的右子节点
      y.parent = x;          // 更新y的父节点为x
  }
  ```
- 典型应用：LeetCode 460. LFU缓存（可用红黑树维护访问频率，实现O(log n)操作）

#### 4. B树（多路平衡查找树）
B树是专为**磁盘存储场景**设计的多路平衡查找树，核心优势是“降低树高”——通过单个节点存储多个键值对，减少磁盘IO次数（磁盘IO速度远慢于内存访问，减少IO是性能优化关键），广泛用于数据库索引（如MySQL InnoDB的聚簇索引）、文件系统目录结构。

##### 4.1 核心定义（m阶B树）
“m阶”表示B树的“最大路数”，即单个节点最多包含`m`个子节点，需满足以下5个特性（LeetCode解题中需牢记特性以判断树的合法性）：
1. 键值有序：每个节点内的键按**升序排列**（如键k₁<k₂<…<kₙ）；
2. 子节点数量：若节点有`n`个键，则必有`n+1`个子节点（左子树<k₁，k₁<子树₂<k₂，…，kₙ<右子树）；
3. 节点容量限制：
   - 非根节点：键数量`⌈m/2⌉ - 1 ≤ n ≤ m-1`（保证节点不“过空”或“过满”，维持平衡）；
   - 根节点：键数量`0 ≤ n ≤ m-1`（允许根节点只有1个键，简化初始化）；
4. 平衡特性：所有**叶子节点在同一层**（无“深叶子”“浅叶子”，保证查询路径长度一致）；
5. 叶子节点性质：叶子节点无实际子节点（或子节点为null，仅存储键值）。

**示例**：3阶B树（m=3，最大子节点数3，键数量1~2）
- 非根节点：最少1个键、2个子节点；最多2个键、3个子节点；
- 叶子节点：均在最底层，键数量1~2。

## 链表

链表是一种线性数据结构，由节点组成，每个节点包含数据域和指针域（指向指向下一个节点），通过指针连接形成链式结构。与数组相比，链表的优势是插入和删除操作效率高（O(1)，只需修改指针），但随机访问效率低（O(n)，需从头遍历）。LeetCode 中链表相关题目多围绕环判断、特殊栈实现等展开。

#### 链表有无环
判断链表是否存在环，以及找到环的入口，是链表操作的经典问题，核心考点是**双指针技巧**（快慢指针），可在 O(1) 空间复杂度内解决。

- **判断是否有环**
  - 原理：使用两个指针，快指针（fast）每次移动 2 步，慢指针（slow）每次移动 1 步。若链表有环，两指针最终会在环内相遇；若无环，快指针会先到达链表尾部（null）。
  - Java 代码模板：
    ```java
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false; // 空链表或单节点无环
        }
        ListNode slow = head;
        ListNode fast = head.next; // 初始错开，避免直接相等
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false; // 快指针到达尾部，无环
            }
            slow = slow.next;      // 慢指针走1步
            fast = fast.next.next; // 快指针走2步
        }
        return true; // 相遇，有环
    }
    ```

- **找到环的入口**
  - 原理：当快慢指针相遇后，将其中一个指针重置为头节点，两指针以相同速度（每次 1 步）移动，再次相遇的节点即为环的入口。
    - 数学推导：设头节点到入口距离为 `a`，入口到相遇点距离为 `b`，环长度为 `c`，则相遇时慢指针走了 `a + b`，快指针走了 `a + b + k*c`（k 为圈数）。因快指针速度是慢指针的 2 倍，故 `2*(a + b) = a + b + k*c`，化简得 `a = k*c - b`，即头节点到入口的距离等于相遇点到入口的环剩余距离。
  - Java 代码模板：
    ```java
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        ListNode slow = head;
        ListNode fast = head;
        // 第一步：判断是否有环并找到相遇点
        do {
            if (fast == null || fast.next == null) {
                return null; // 无环
            }
            slow = slow.next;
            fast = fast.next.next;
        } while (slow != fast);
        // 第二步：找环入口
        fast = head; // 快指针重置为头节点
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next; // 两指针同速移动
        }
        return slow; // 相遇点即为入口
    }
    ```

- **典型例题**：LeetCode 141. 环形链表（判断环）、LeetCode 142. 环形链表 II（找入口）。


#### 双端队列、栈
双端队列（Deque）是一种允许在两端都进行插入和删除操作的队列，兼具栈和队列的特性；栈是一种“后进先出”（LIFO）的线性结构，仅允许在一端（栈顶）操作。两者在 LeetCode 中常作为辅助结构优化算法效率。

- **双端队列（Deque）**
  - 核心特性：支持 `addFirst()`/`removeFirst()`（头部操作）和 `addLast()`/`removeLast()`（尾部操作），所有操作均为 O(1) 时间复杂度。
  - 与栈、队列的关系：
    - 模拟栈：用 `addLast()` 入栈，`removeLast()` 出栈（尾部操作）；
    - 模拟队列：用 `addLast()` 入队，`removeFirst()` 出队（尾部入、头部出）。
  - 典型应用：滑动窗口最大值（维护单调队列）
    ```java
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] res = new int[n - k + 1];
        Deque<Integer> deque = new LinkedList<>(); // 存储索引，保证对应值单调递减
        
        for (int i = 0; i < n; i++) {
            // 移除窗口外的元素（队首超出左边界）
            while (!deque.isEmpty() && deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            // 移除队列中比当前元素小的元素（这些元素不可能成为最大值）
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            deque.addLast(i);
            // 窗口大小达标后，队首即为当前窗口最大值
            if (i >= k - 1) {
                res[i - k + 1] = nums[deque.peekFirst()];
            }
        }
        return res;
    }
    ```

- **栈（Stack）**
  - 核心特性：仅支持 `push()`（入栈）、`pop()`（出栈）、`peek()`（查看栈顶）操作，均为 O(1) 时间复杂度。
  - 典型应用：括号匹配、表达式求值、单调栈找下一个更大元素。
    ```java
    // 单调栈示例：找下一个更大元素
    public int[] nextGreaterElement(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        Arrays.fill(res, -1);
        Deque<Integer> stack = new LinkedList<>(); // 存储索引，维护单调递减栈
        
        for (int i = 0; i < n; i++) {
            // 栈顶元素小于当前元素，说明当前元素是栈顶元素的下一个更大元素
            while (!stack.isEmpty() && nums[stack.peek()] < nums[i]) {
                int idx = stack.pop();
                res[idx] = nums[i];
            }
            stack.push(i);
        }
        return res;
    }
    ```


#### 最大最小栈
最大最小栈是普通栈的扩展，支持在 O(1) 时间内获取栈中的最大值或最小值，核心思路是**使用辅助栈存储对应位置的最值**。

- **设计思路**
  - 主栈：存储原始元素，支持正常的 push、pop、top 操作；
  - 辅助栈（最大栈/最小栈）：与主栈同步，栈顶元素始终是主栈对应位置的最大值（或最小值）。
    - 入栈时：若新元素大于等于最大栈栈顶，则将新元素压入最大栈；否则，重复压入当前最大栈栈顶（保证与主栈长度一致）；
    - 出栈时：主栈和辅助栈同时弹出元素（保持长度同步）；
    - 获取最值时：直接返回辅助栈栈顶。

- **Java 代码实现（最大栈）**
  ```java
  class MaxStack {
      private Deque<Integer> mainStack; // 主栈
      private Deque<Integer> maxStack;  // 辅助栈（存储最大值）

      public MaxStack() {
          mainStack = new LinkedList<>();
          maxStack = new LinkedList<>();
      }

      // 入栈
      public void push(int x) {
          mainStack.push(x);
          // 最大栈压入当前最大值（新元素与栈顶取最大）
          if (maxStack.isEmpty()) {
              maxStack.push(x);
          } else {
              maxStack.push(Math.max(x, maxStack.peek()));
          }
      }

      // 出栈
      public void pop() {
          mainStack.pop();
          maxStack.pop(); // 同步弹出
      }

      // 获取栈顶元素
      public int top() {
          return mainStack.peek();
      }

      // 获取最大值
      public int getMax() {
          return maxStack.peek();
      }
  }
  ```

- **典型例题**：LeetCode 155. 最小栈（实现最小栈）、LeetCode 716. 最大栈（实现最大栈及附加操作）。
## 数组

数组是一种**连续存储的线性数据结构**，所有元素在内存中占用连续空间，支持通过索引（下标）快速访问（O(1) 时间复杂度），但插入/删除操作（尤其是中间位置）效率较低（需移动元素，O(n) 时间复杂度）。LeetCode 中数组类题目高频围绕“高效查找”“前缀和优化”“堆应用”展开，以下是核心考点的详细解析。


#### 哈希散列（数组的高效查找优化）
哈希散列（Hash）的核心是**通过哈希函数将元素映射到数组下标**，将“线性查找”（O(n)）优化为“直接访问”（O(1)），是解决“两数之和”“重复元素判断”等问题的关键工具。在数组场景中，常用 `HashMap`（键值对映射）或 `HashSet`（元素去重）实现。

- **核心原理**
  1. 哈希函数：将元素值（如整数、字符串）转换为数组下标（或哈希表中的桶位置），例如 `hash(key) = key % 数组长度`；
  2. 解决哈希冲突：若不同元素映射到同一下标（冲突），常用“链地址法”（如 `HashMap` 中每个桶存储链表/红黑树）；
  3. 数组与哈希的结合：利用数组索引的快速访问特性，当元素值范围可控时，可直接用数组作为“哈希表”（比 `HashMap` 更高效）。

- **常见应用场景与代码模板**
  ##### 场景 1：两数之和（找目标和的元素下标）
  问题：给定数组 `nums` 和目标值 `target`，找到两个元素之和为 `target` 的下标（假设唯一解）。  
  思路：用 `HashMap` 存储“元素值→下标”，遍历数组时，检查 `target - 当前元素` 是否在哈希表中，存在则返回下标对。
  ```java
  public int[] twoSum(int[] nums, int target) {
      Map<Integer, Integer> numToIndex = new HashMap<>(); // 存储元素值与下标的映射
      for (int i = 0; i < nums.length; i++) {
          int complement = target - nums[i];
          // 若互补元素存在，直接返回结果
          if (numToIndex.containsKey(complement)) {
              return new int[]{numToIndex.get(complement), i};
          }
          // 否则将当前元素加入哈希表
          numToIndex.put(nums[i], i);
      }
      return new int[0]; // 题目保证有解，此句仅为语法兼容
  }
  ```

  ##### 场景 2：数组去重（判断是否存在重复元素）
  问题：给定数组，判断是否存在重复元素。  
  思路：用 `HashSet` 存储遍历过的元素，若当前元素已在集合中，说明存在重复。
  ```java
  public boolean containsDuplicate(int[] nums) {
      Set<Integer> seen = new HashSet<>();
      for (int num : nums) {
          if (seen.contains(num)) {
              return true;
          }
          seen.add(num);
      }
      return false;
  }
  ```

  ##### 场景 3：数组作为哈希表（元素值范围可控）
  问题：给定长度为 `n` 的数组，元素值均在 `0~n-1` 范围内，找出重复的元素。  
  思路：利用“元素值=数组下标”的特性，直接用原数组标记已访问元素（空间复杂度 O(1)）。
  ```java
  public int findDuplicate(int[] nums) {
      for (int num : nums) {
          int index = Math.abs(num); // 元素值可能已被标记为负数，取绝对值
          if (nums[index] < 0) {
              return index; // 已标记过，说明是重复元素
          }
          nums[index] = -nums[index]; // 标记为负数，表示已访问
      }
      return -1;
  }
  ```

- **典型例题**：LeetCode 1. 两数之和、LeetCode 217. 存在重复元素、LeetCode 448. 找到所有数组中消失的数字。


#### 完全二叉树以及堆（数组的层次存储应用）
堆是一种**完全二叉树**的逻辑结构，通常用数组实现（利用完全二叉树的“父子节点下标关系”），核心特性是“堆顶元素为最值”（大根堆：堆顶最大；小根堆：堆顶最小），常用于“Top K 问题”“中位数查找”等场景。

- **完全二叉树与数组的映射关系**
  完全二叉树的所有节点按“层序遍历”顺序存储在数组中，若父节点下标为 `i`（从 0 开始），则：
  - 左子节点下标：`2*i + 1`；
  - 右子节点下标：`2*i + 2`；
  - 父节点下标：`(i - 1) / 2`（整数除法）。  
  这一关系是堆操作（上浮、下沉）的基础。

- **堆的核心操作（以大根堆为例）**
  ##### 1. 下沉（Heapify）：维护堆的性质
  当堆顶元素被替换（如删除堆顶后用最后一个元素填充），需将新堆顶向下调整，直到满足“父节点≥子节点”。
  ```java
  // 对下标 i 进行下沉操作，堆的有效长度为 heapSize
  private void heapify(int[] heap, int heapSize, int i) {
      int largest = i; // 初始化最大值为当前节点
      int left = 2 * i + 1; // 左子节点下标
      int right = 2 * i + 2; // 右子节点下标

      // 若左子节点大于当前最大值，更新最大值
      if (left < heapSize && heap[left] > heap[largest]) {
          largest = left;
      }
      // 若右子节点大于当前最大值，更新最大值
      if (right < heapSize && heap[right] > heap[largest]) {
          largest = right;
      }
      // 若最大值不是当前节点，交换并递归下沉
      if (largest != i) {
          int temp = heap[i];
          heap[i] = heap[largest];
          heap[largest] = temp;
          heapify(heap, heapSize, largest); // 递归处理子节点
      }
  }
  ```

  ##### 2. 建堆：将无序数组转换为堆
  从最后一个非叶子节点（下标 `(n-2)/2`）开始，依次对每个节点执行下沉操作，最终形成堆。
  ```java
  private void buildHeap(int[] heap) {
      int n = heap.length;
      // 从最后一个非叶子节点开始下沉
      for (int i = (n - 2) / 2; i >= 0; i--) {
          heapify(heap, n, i);
      }
  }
  ```

- **堆的典型应用场景**
  ##### 场景 1：Top K 问题（找数组中前 K 个最大元素）
  思路：用**小根堆**存储前 K 个最大元素（堆顶为当前 K 个元素中的最小值），遍历数组时，若元素大于堆顶，则替换堆顶并下沉，最终堆中元素即为结果。
  ```java
  public int[] topKFrequent(int[] nums, int k) {
      // 1. 统计元素出现频率（用 HashMap）
      Map<Integer, Integer> freqMap = new HashMap<>();
      for (int num : nums) {
          freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
      }

      // 2. 用小根堆维护前 K 个高频元素（堆中存储“频率-元素”对）
      PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]); // 按频率升序排序
      for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
          int freq = entry.getValue();
          int num = entry.getKey();
          if (minHeap.size() < k) {
              minHeap.offer(new int[]{freq, num});
          } else {
              // 若当前频率大于堆顶频率，替换堆顶
              if (freq > minHeap.peek()[0]) {
                  minHeap.poll();
                  minHeap.offer(new int[]{freq, num});
              }
          }
      }

      // 3. 提取堆中元素（结果需逆序，因堆顶是最小的高频元素）
      int[] res = new int[k];
      for (int i = k - 1; i >= 0; i--) {
          res[i] = minHeap.poll()[1];
      }
      return res;
  }
  ```

  ##### 场景 2：堆排序（数组排序）
  思路：先将数组建为大根堆，再依次将堆顶（最大值）与堆尾元素交换，缩小堆的有效长度并下沉，最终数组有序。
  ```java
  public void heapSort(int[] nums) {
      int n = nums.length;
      buildHeap(nums); // 建大根堆

      // 依次将堆顶与堆尾交换，维护堆性质
      for (int i = n - 1; i > 0; i--) {
          // 交换堆顶（最大值）与当前堆尾
          int temp = nums[0];
          nums[0] = nums[i];
          nums[i] = temp;
          // 对剩余元素（0~i-1）执行下沉，维护大根堆
          heapify(nums, i, 0);
      }
  }
  ```

- **典型例题**：LeetCode 215. 数组中的第K个最大元素、LeetCode 347. 前 K 个高频元素、LeetCode 912. 排序数组（堆排序实现）。


#### 二分查找（有序数组的高效查找）
二分查找是针对**有序数组**的查找算法，核心是“每次将查找范围缩小一半”，时间复杂度 O(log n)，比线性查找（O(n)）高效得多，适用于“有序数组的定值查找”“边界查找”等场景。

- **核心前提与思路**
  1. 前提：数组必须有序（升序或降序，本文以升序为例）；
  2. 思路：定义左边界 `left` 和右边界 `right`，计算中间下标 `mid`，比较 `nums[mid]` 与目标值 `target`：
     - 若 `nums[mid] == target`：找到目标，返回结果；
     - 若 `nums[mid] < target`：目标在右半区，调整 `left = mid + 1`；
     - 若 `nums[mid] > target`：目标在左半区，调整 `right = mid - 1`；
  3. 关键：边界的定义（左闭右闭 `[left, right]` 或左闭右开 `[left, right)`），需严格统一逻辑。

- **常见应用场景与代码模板**
  ##### 场景 1：基础二分查找（找定值的下标）
  问题：给定升序数组 `nums` 和目标值 `target`，找到 `target` 在数组中的下标，若不存在返回 -1。  
  思路：采用左闭右闭区间 `[left, right]`，终止条件为 `left > right`。
  ```java
  public int search(int[] nums, int target) {
      int left = 0;
      int right = nums.length - 1; // 右边界初始为数组最后一个下标（闭区间）

      while (left <= right) { // 闭区间：left == right 时仍需判断
          int mid = left + (right - left) / 2; // 避免 (left + right) 溢出
          if (nums[mid] == target) {
              return mid; // 找到目标，返回下标
          } else if (nums[mid] < target) {
              left = mid + 1; // 目标在右半区，左边界右移
          } else {
              right = mid - 1; // 目标在左半区，右边界左移
          }
      }
      return -1; // 未找到目标
  }
  ```

  ##### 场景 2：查找左边界（第一个≥target 的元素下标）
  问题：给定升序数组 `nums` 和目标值 `target`，找到第一个大于等于 `target` 的元素下标（如 `nums = [1,3,5,6]`，`target=4`，返回 2）。  
  思路：用二分查找缩小范围，最终 `left` 即为左边界。
  ```java
  public int findLeftBound(int[] nums, int target) {
      int left = 0;
      int right = nums.length; // 右边界初始为数组长度（左闭右开区间）

      while (left < right) { // 左闭右开：left == right 时终止
          int mid = left + (right - left) / 2;
          if (nums[mid] >= target) {
              right = mid; // 目标在左半区，右边界左移（不排除 mid）
          } else {
              left = mid + 1; // 目标在右半区，左边界右移
          }
      }
      return left; // 最终 left == right，即为左边界
  }
  ```

  ##### 场景 3：查找右边界（最后一个≤target 的元素下标）
  问题：给定升序数组 `nums` 和目标值 `target`，找到最后一个小于等于 `target` 的元素下标（如 `nums = [1,3,5,6]`，`target=4`，返回 1）。  
  思路：类似左边界，调整判断条件，最终 `right` 即为右边界。
  ```java
  public int findRightBound(int[] nums, int target) {
      int left = 0;
      int right = nums.length - 1; // 左闭右闭区间

      while (left <= right) {
          int mid = left + (right - left) / 2;
          if (nums[mid] <= target) {
              left = mid + 1; // 目标在右半区，左边界右移（不排除 mid）
          } else {
              right = mid - 1; // 目标在左半区，右边界左移
          }
      }
      return right; // 最终 right 即为右边界（若 target 过小，返回 -1）
  }
  ```

- **典型例题**：LeetCode 704. 二分查找、LeetCode 35. 搜索插入位置（左边界）、LeetCode 69. x 的平方根（右边界）。


#### 前缀和（数组区间和的高效优化）
前缀和是数组场景中**优化区间和计算**的核心预处理技术，通过提前存储“从数组起点到各下标的累加和”，将原本需要遍历的 O(n) 区间和查询，降至 O(1) 直接计算，广泛应用于“子数组和问题”“频繁区间查询”等场景，尤其适合 LeetCode 中“子数组和等于 k”“连续子数组最大和”类题目。


### 一、核心原理（以一维数组为例）
#### 1. 前缀和数组定义
设原数组为 `nums`（长度为 `n`），定义前缀和数组 `prefixSum`（长度为 `n+1`，多开一个位置简化计算），其中：
- `prefixSum[0] = 0`（哨兵位，避免处理边界时的复杂判断）；
- `prefixSum[i] = nums[0] + nums[1] + ... + nums[i-1]`（即前 `i` 个元素的累加和）。

#### 2. 区间和计算推导
对于原数组中 **下标 `l` 到 `r` 的闭区间**（`0 ≤ l ≤ r < n`），其区间和为：
```
sum(nums[l..r]) = nums[l] + nums[l+1] + ... + nums[r]
```
结合前缀和数组的定义，可转化为：
```
sum(nums[l..r]) = prefixSum[r+1] - prefixSum[l]
```
**推导过程**：
- `prefixSum[r+1] = nums[0] + ... + nums[l-1] + nums[l] + ... + nums[r]`（前 `r+1` 个元素和）；
- `prefixSum[l] = nums[0] + ... + nums[l-1]`（前 `l` 个元素和）；
- 两者相减，恰好抵消前 `l` 个元素，剩余 `nums[l]` 到 `nums[r]` 的和。


### 二、一维前缀和：基础应用与代码模板
#### 1. 场景 1：静态区间和查询（多次查询）
**问题**：给定一维数组 `nums`，实现一个类，支持多次查询“下标 `l` 到 `r` 的区间和”（如 LeetCode 303. 区域和检索 - 数组不可变）。  
**思路**：初始化时预处理前缀和数组，查询时直接套用公式计算。

**Java 代码模板**：
```java
class NumArray {
    // 前缀和数组（prefixSum[0] = 0，prefixSum[i] = 前i个元素和）
    private int[] prefixSum;

    // 初始化：预处理前缀和
    public NumArray(int[] nums) {
        int n = nums.length;
        prefixSum = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            // 递推公式：当前前缀和 = 前一个前缀和 + 原数组当前元素（nums[i-1]）
            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];
        }
    }

    // 查询 [left, right] 区间的和（left和right为原数组下标，0-based）
    public int sumRange(int left, int right) {
        // 核心公式：区间和 = prefixSum[right+1] - prefixSum[left]
        return prefixSum[right + 1] - prefixSum[left];
    }
}

// 用法示例
// NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
// numArray.sumRange(0, 2); // 返回 (-2) + 0 + 3 = 1
// numArray.sumRange(2, 5); // 返回 3 + (-5) + 2 + (-1) = -1
```

#### 2. 场景 2：子数组和等于 k 的数量（高频考点）
**问题**：给定数组 `nums` 和整数 `k`，统计有多少个连续子数组的和等于 `k`（如 LeetCode 560. 和为 K 的子数组）。  
**思路**：结合前缀和与哈希表，将“子数组和 = k”转化为“前缀和差值 = k”，避免暴力枚举的 O(n²) 复杂度。

**核心推导**：
- 设子数组 `nums[l..r]` 和为 `k`，则 `prefixSum[r+1] - prefixSum[l] = k`；
- 变形得 `prefixSum[l] = prefixSum[r+1] - k`，即统计“当前前缀和 `prefixSum[r+1]` 减去 `k` 后，在之前出现过的次数”，累加次数即为结果。

**Java 代码模板**：
```java
public int subarraySum(int[] nums, int k) {
    // 哈希表：key = 前缀和值，value = 该前缀和出现的次数
    Map<Integer, Integer> prefixSumCount = new HashMap<>();
    // 初始条件：前缀和为 0 出现过 1 次（对应 l=0 的情况，即子数组从 0 开始）
    prefixSumCount.put(0, 1);

    int currentPrefixSum = 0; // 当前遍历到的前缀和（prefixSum[i]，i从1开始）
    int result = 0;           // 满足条件的子数组数量

    for (int num : nums) {
        // 1. 更新当前前缀和（遍历到第 i 个元素，currentPrefixSum = prefixSum[i+1]）
        currentPrefixSum += num;

        // 2. 计算需要找的前缀和：target = currentPrefixSum - k
        int target = currentPrefixSum - k;
        // 若 target 存在于哈希表中，说明有对应的 l，累加次数
        if (prefixSumCount.containsKey(target)) {
            result += prefixSumCount.get(target);
        }

        // 3. 将当前前缀和加入哈希表（注意：先统计再加入，避免重复计算当前元素）
        prefixSumCount.put(currentPrefixSum, 
                          prefixSumCount.getOrDefault(currentPrefixSum, 0) + 1);
    }

    return result;
}

// 示例：nums = [1,1,1], k=2 → 结果为 2（子数组 [1,1]（0-1）、[1,1]（1-2））
```


### 三、二维前缀和：子矩阵和查询
#### 1. 核心原理（扩展到二维）
对于二维数组 `matrix`（行 `m`，列 `n`），定义二维前缀和数组 `prefixSum`（行 `m+1`，列 `n+1`），其中 `prefixSum[i][j]` 表示“以 (0,0) 为左上角、(i-1,j-1) 为右下角的子矩阵和”。

#### 2. 二维前缀和递推公式
计算 `prefixSum[i][j]` 时，需考虑“上、左、左上”三个方向的重叠区域，公式为：
```
prefixSum[i][j] = matrix[i-1][j-1] 
                + prefixSum[i-1][j]   // 上方子矩阵和
                + prefixSum[i][j-1]   // 左侧子矩阵和
                - prefixSum[i-1][j-1] // 减去重复计算的左上子矩阵和
```

#### 3. 子矩阵和查询公式
对于“左上角 (row1, col1)、右下角 (row2, col2)”的子矩阵（原数组下标，0-based），其和为：
```
sum = prefixSum[row2+1][col2+1] 
    - prefixSum[row1][col2+1]   // 减去上方多余区域
    - prefixSum[row2+1][col1]   // 减去左侧多余区域
    + prefixSum[row1][col1]     // 加回重复减去的左上区域
```

#### 4. Java 代码模板（LeetCode 304. 二维区域和检索 - 矩阵不可变）
```java
class NumMatrix {
    private int[][] prefixSum; // 二维前缀和数组

    public NumMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }
        int m = matrix.length;    // 原矩阵行数
        int n = matrix[0].length; // 原矩阵列数
        prefixSum = new int[m + 1][n + 1];

        // 预处理二维前缀和
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 递推公式：当前前缀和 = 原元素 + 上方 + 左侧 - 左上重叠
                prefixSum[i][j] = matrix[i-1][j-1] 
                                + prefixSum[i-1][j] 
                                + prefixSum[i][j-1] 
                                - prefixSum[i-1][j-1];
            }
        }
    }

    // 查询左上角 (row1, col1) 到右下角 (row2, col2) 的子矩阵和
    public int sumRegion(int row1, int col1, int row2, int col2) {
        // 核心公式：子矩阵和 = 总前缀和 - 上方 - 左侧 + 左上重叠
        return prefixSum[row2+1][col2+1] 
              - prefixSum[row1][col2+1] 
              - prefixSum[row2+1][col1] 
              + prefixSum[row1][col1];
    }
}

// 用法示例
// NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);
// numMatrix.sumRegion(2, 1, 4, 3); // 返回 (1+2+0+1) + (4+1+0+1) + (1+0+3+0) = 14
```


### 四、关键注意事项
1. **哨兵位的作用**：前缀和数组多开一个 `prefixSum[0]`（一维）或 `prefixSum[0][*]`/`prefixSum[*][0]`（二维），避免计算时判断“是否为第一行/第一列”，简化代码；
2. **哈希表的初始条件**：在“子数组和等于 k”问题中，必须初始化 `prefixSumCount.put(0, 1)`，否则会漏掉“子数组从 0 开始”的情况（如 `nums = [k]` 时，`currentPrefixSum = k`，`target = 0`，需统计到初始的 1 次）；
3. **数据溢出问题**：若数组元素较大或长度较长，需用 `long` 类型存储前缀和（如 `long[] prefixSum`），避免 int 类型溢出（例如 LeetCode 中数组长度达 1e5，每个元素 1e5，累加和会超过 int 最大值 2e9）。


### 五、典型例题
- 一维基础：LeetCode 303. 区域和检索 - 数组不可变；
- 一维进阶：LeetCode 560. 和为 K 的子数组、LeetCode 974. 和可被 K 整除的子数组；
- 二维应用：LeetCode 304. 二维区域和检索 - 矩阵不可变、LeetCode 1314. 矩阵区域和。