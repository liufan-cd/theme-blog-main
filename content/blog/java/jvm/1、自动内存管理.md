## 运行时内存划分

### 程序计数器
每一个线程都有一个程序计数器，用于记录当前线程执行的字节码行号。分支、循环、跳转、异常处理、线程恢复等都是依靠该指示器工作。

### java虚拟机栈
和程序计数器同理，都是每一个线程私有的一块内存空间，用于保存栈帧。栈帧保存了这个方法执行的局部变量表、操作数栈、动态连接等信息。每一个方法被调用直至完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

### 本地方法栈
和虚拟机栈类似，不同的是本地方法栈是为了执行本地（Native）方法使用的，而虚拟机栈是为了执行字节码使用的。

### java堆
各个线程所共有的一块内存区域也是java虚拟机中管理的最大的一块内存区域，此内存区域的唯一目的就是存放实例对象，java几乎所有的对象都是在这个区域上分配内存。自然而然，这个区域也是垃圾收集器管理的内存区域。从垃圾回收的角度来看，由于现代垃圾收集器大都基于分代收集理论设计的，所以java堆中经常会出现“新生代”，“老年代”等专用名词，但是实际上这个概念是不完整的，这些区域划分仅仅是一部分垃圾收集器的共同特性或者说是设计风格而已，而非某个java虚拟机具体实现的固有布局，更不是《Java虚拟机规范》里对java堆的进一步细致划分。

### 方法区
方法区与java堆一样，是各个线程共享的内存区域，用于存放已被java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。在jdk8以前，方法区也常常称为永久代，这是因为垃圾收集器的分代理念将永久代的视线扩展到了方法区实现，实际上到了jdk7 HotSpot就将原本永久代存放的字符串常量池、静态变量等移至java堆中。jdk8中完全废弃了永久代，该为元空间保存剩余部分。

### 运行时常量池
CLass文件中除了有类模板、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期产生的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

### 直接内存
不是java定义中的内存划分区域，但是这部分内存也会被频繁使用，比如nio工作时使用的缓冲区，就是java堆外的直接内存。

## HotSpot虚拟机对象

### 对象的创建

