---
title: 🧠 操作系统概述
summary: 本篇主要讲述自己学习观看操作系统视频后的一些思考后的总结。
date: 2025-09-08
editable: false
authors:
  - admin
tags:
  - 计算机基础
  - 操作系统
---
# 概述

本篇主要讲述自己学习观看操作系统视频后的一些思考后的总结。

## 学习资料链接
{{< bilibili BV19r4y1b7Aw >}}

## 综述（快速导航）

{{% callout note %}}
本文记录作者学习操作系统视频后的关键要点、理解与进一步阅读建议。目标是给出概念图、核心术语以及学习路径，便于快速回顾与复习。
{{% /callout %}}

### 什么是操作系统

计算机（computer）是一种能按程序自动、高速处理数据的电子设备。操作系统（Operating System, OS）是管理硬件资源、为应用程序提供运行环境的系统软件，它负责进程管理、内存管理、设备管理、文件系统与安全保护等核心功能。

{{% callout info %}}
操作系统的本质是“资源管理者”和“用户接口”。在现代计算机中，操作系统负责把复杂的硬件细节对上层屏蔽，让程序员能使用更高层的抽象。
{{% /callout %}}

### 启动过程（Boot）

按下开机键后，硬件上电自检（POST），主板固件（BIOS/UEFI）查找并加载引导器，将操作系统内核加载到内存并将控制权交给内核。内核完成硬件初始化、内存管理（可能包括分页/段页）并启动第一个用户进程（如 shell / 登录管理器）。

### 内核态与用户态

![内核态和用户态](../内核态和用户态.png)

{{% callout warning %}}
CPU 将指令分为特权指令与非特权指令。只有内核（内核态）可以执行特权指令，普通应用在用户态运行以保障系统稳定性与安全。
{{% /callout %}}

主要目的：权限保护与隔离，防止用户程序直接操作关键硬件或破坏其他进程。

### 系统调用（syscall）

当用户态程序需要执行受限操作（如 I/O、内存映射、进程管理）时，通过系统调用接口进入内核，由内核代为执行相应操作并返回结果。

### 进程与并发

进程是正在执行的程序实例。操作系统通过进程调度在 CPU 上切换多个进程，使得多任务看起来“同时”运行。

![多进程图像](../多进程图像.png)

以下为一个简明的可视化思路（可在支持的页面使用 markmap 渲染）：

```markmap {height="260px"}
- 操作系统
  - 启动 & 引导
  - 进程管理
    - 进程 (Process)
    - 线程 (Thread)
    - 调度 (Scheduler)
  - 内存管理
    - 虚拟内存
    - 分页/段页
  - 文件系统
  - 设备管理
```

### 内核栈与用户栈

每个进程通常拥有用户栈（user stack）与内核栈（kernel stack）。当发生系统调用或中断时，CPU 切换到内核态并使用内核栈以保证内核运行的安全与独立性。

常见问答：为什么不只用一个栈？

- 系统栈通常较小且受保护，若把用户调用链放在系统栈，会耗尽系统栈资源。
- 用户栈存在用户空间，不适合保存内核敏感数据或处理中断保护问题。
 - 

## 内存管理（模块）

下面按你要求的三个小节说明内存管理的设计与必要性：

### 1) 操作系统对物理内存采用分页（Paging），及其优势

操作系统在物理内存层面一般以固定大小的页框（frame）来管理物理内存（常见页大小为 4KB、2MB 等），把内存按页进行分配与置换，这就是分页。

{{% callout info %}}
分页把内存划分为等大小单元：虚拟页（Virtual Page）与物理页框（Frame）。内存分配、回收与换出都以页为单位进行。
{{% /callout %}}

分页的优势：

- 避免外部碎片：固定块分配不会产生无法利用的大块空闲区。
- 简化分配与回收：页表、位图等数据结构利于高效管理空闲页。
- 支持虚拟内存：可将不常用页换出到磁盘（swap），按需加载，扩展可用地址空间。
- 易于硬件加速：TLB（快表）缓存常用映射，页级权限 (R/W/X) 实现访问控制。

### 2) 面向程序的分段（Segmentation），及其优势

程序语义上按段组织地址空间：代码段、数据段、堆、栈等。分段以段为单位描述逻辑对象，每个段有基址、长度与权限。

{{% callout info %}}
分段提供程序级别的语义边界与保护，便于编译器、链接器与运行时的管理。
{{% /callout %}}

分段的优势：

- 语义清晰：段对应模块或资源（如函数库、全局数据），便于理解与管理。
- 边界/权限检查：段表可实现界限检查，防止越界访问并提高安全性。
- 便于共享与重定位：可以按段共享库或在进程间映射相同段实现共享。

缺点：单独使用分段会产生外部碎片，分配/回收复杂，不利于高效置换。

### 3) 段页结合（Segmentation + Paging）的实现与必要性

段页结合是将分段语义与分页物理管理结合的方案：程序按段组织（逻辑层面），物理内存按页管理（物理层面）。

实现要点（高层）:

- 段表（Segment Table）存储每个段的基址/长度/权限；段选择子 + 段内偏移用于定位段内虚拟地址并做界限检查；
- 段内地址再被分页机制切分为页号（VPN）与页内偏移（offset），由页表映射到物理帧（PFN）；
- 最终物理地址由 PFN 与 offset 合成；硬件（MMU）或软件协同完成段->页->物理地址的转换。

逻辑示意：

```text
逻辑地址 = 段选择子 : 段内偏移
  ↓ 段表（界限检查，得到段基址）
段内虚拟地址 = 段基址 + 段内偏移
  ↓ 页表（VPN -> PFN）
物理地址 = PFN << offset_bits | offset
```

必要性与好处：

- 折中取长：分段提供模块化、语义保护；分页提供高效物理管理与置换，段页结合同时保留两者优势。
- 减少碎片并提高置换效率：分页消除了分段的外部碎片问题，同时分段便于逻辑保护与共享。
- 灵活的共享和权限策略：段用于逻辑共享（如库），页用于物理共享与高速缓存优化；段与页的权限组合提供更细粒度保护。

{{% callout note %}}
实现练习建议：先实现单级页表的虚拟地址映射，再增加段表层，观察 TLB miss、置换和换页代价的变化。
{{% /callout %}}

### 具体寻址示例（数值化步骤）

下面用具体的数值举例，说明分页、分段与段页结合在运行时如何完成地址转换。

#### A. 分页（Paging）示例

假设：32 位虚拟地址，页大小 4KB（offset = 12 位），因此 VPN = 20 位。

- 虚拟地址示例：0x12345ABC
  - offset = 低 12 位 = 0xABC
  - VPN = 高 20 位 = 0x12345

操作系统/硬件流程：

1. CPU 提取虚拟地址 0x12345ABC；
2. 从 TLB 查找 VPN=0x12345 的映射；若命中直接得到 PFN；若未命中，读页表：
   - 假设页表条目（PTE）为：PFN=0x00A9F, valid=1, R/W=1, U/S=1；
3. 物理帧号 PFN=0x00A9F，与 offset 0xABC 结合：物理地址 = 0x00A9F << 12 | 0xABC = 0x00A9F000 + 0xABC = 0x00A9FABC；
4. CPU 访问该物理地址，若 PTE 的 valid=0 则触发缺页中断（page fault），由操作系统将所需页从磁盘换入并更新 PTE 后重试。

PTE（页表项）常见字段：PFN、valid/present、R/W、U/S（用户/超级用户）、accessed、dirty。

#### B. 分段（Segmentation）示例

假设：进程有一张段表，段 2（代码段）在段表中的条目为：base=0x00400000, limit=0x00100000, 权限=R/X。

- 程序生成逻辑地址（SegmentSelector:Offset）为：2:0x00001234。

运行时流程：

1. CPU 或运行时使用段选择子 2 去段表查找段条目；检查 offset(0x1234) 是否小于 limit（0x00100000），如果越界则触发段异常；
2. 通过段基址加偏移得到段内虚拟地址（线性地址）：0x00400000 + 0x00001234 = 0x00401234；
3. 接下来（如果采用纯分段体系）该线性地址直接作为物理地址的一部分（或交由分段机制进一步转换），否则进入分页阶段。

分段表项常见字段：base、limit、权限（R/W/X）、存在位等。

#### C. 段页结合（Segmentation + Paging）完整示例

结合上面两个例子：

- 段选择子 2 -> 段表条目：base = 0x00400000, limit 足够大；
- 段内偏移 = 0x00001234；段基址 + 偏移得到线性地址 0x00401234；
- 设页大小仍然为 4KB（offset 12 位）：
  - offset = 0x234 (低 12 位)
  - VPN = (0x00401234 >> 12) = 0x00401 (示例值)

运行时转换步骤：

1. 段表查找：用段选择子取得段基址并做界限检查；
2. 计算段内线性地址（segment_base + offset）得到 0x00401234；
3. 将线性地址分为 VPN 与 offset，查 TLB；若未命中则走页表：
   - 假设页表映射 VPN=0x00401 -> PFN=0x00B2C，PTE valid=1；
4. 物理地址 = PFN << 12 | offset = 0x00B2C000 | 0x234 = 0x00B2C234；
5. CPU 访问该物理地址完成读写。

操作系统在创建/切换进程时，会为每个进程建立或更新段表与页表：

- 段表用于维持每个段的基址与权限信息（逻辑组织）；
- 页表用于把段内的线性地址映射到物理帧（物理管理）；
- 在上下文切换时，操作系统需要切换 MMU 使用的页表基址（CR3 或等价寄存器）并刷新或有选择地保留 TLB 条目。

{{% callout note %}}
关键点：实际硬件可把部分或全部段/页转换工作放在 MMU/硬件中完成（提高性能），操作系统侧负责建立和维护段表与页表并处理缺页、权限异常等。
{{% /callout %}}

---

## 小结

{{% callout success %}}
内存管理需要在程序语义与物理效率之间做权衡。段页结合是工程上常用的折中方案，既能保持程序的逻辑边界与保护，又能实现高效的页级物理管理。
{{% /callout %}}

