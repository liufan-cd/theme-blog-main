### 原构建逻辑

通过Jenkins进行代码拉取编译打包，然后Jenkins执行对应项目脚本，将打包好的项目生成镜像，并且推送至代码仓库。

[239Jenkins构建](239Jenkins构建.docx)

### 问题
现Jenkins已停止使用，需要重新部署前端项目。

### 现解决方案

1. ``tar -czf iui.tar.gz -C iui .`` 将对应前端文件打包（生成压缩包无顶层目录）。
2. ``cd /home/test/deploy/iui/docker``将对应的iui.tar.gz文件移至当前目录下。
3. 修改build.sh中的相关版本号。
    ```bash
    #!/bin/bash
    APP_VERSION=v2.0.5
    APP_NAME=iui
    docker build -t cy/hm_$APP_NAME:$APP_VERSION .
    ```
4. ``sh build.sh``生成docker镜像。
5. ``docker tag cy/hm_iui:v2.0.5 192.168.10.218:18500/cy/hm_iui:v2.0.5`` 将生成镜像修改tag，指定镜像仓库的ip和端口。
6. ``docker push 192.168.10.218:18500/cy/hm_iui:v2.0.5``推送镜像到远程仓库。
7. ``docker pull 192.168.10.218:18500/cy/hm_iui:v2.0.5``其他服务器拉取镜像。
8. ~~``docker run -d -p 9999:8080 -i --name hm_iui --network docker_default --ip 172.18.0.15 192.168.10.218:18500/cy/hm_iui:v2.0.4``创建容器。~~
ip:192.168.10.239,pwd:/home/test/deploy/user-server/compose中有两个文件:
```bash
# deploy.sh
#!/bin/bash
BASE_PATH=$(cd `dirname $0`; pwd)
cd $BASE_PATH
source ../../set-env.sh

docker-compose -f compose-deploy.yml down -v
docker-compose -f compose-deploy.yml up --no-start
docker-compose -f compose-deploy.yml start

# docker volume ls -qf dangling=true | xargs -r docker volume rm {} &>/dev/null
# docker images|grep none|awk '{print "docker rmi "$3}'|sh &>/dev/null
```

```yml
# compose-deploy.yml
version: '3'
services:
  userserver:
    container_name:  'user'
    image: "cy/hm_user-server:v2.0.1-master"
    restart: always
    ports:
      - "19580:8080"
      - "19581:8078"
      - "19583:19583"
    volumes:
      - $PERSIST_VOLUME/userserver/logs:/logs
      - $PERSIST_VOLUME/userserver/data:/data
      - /etc/localtime:/etc/localtime:ro
      - /usr/share/zoneinfo/Asia/Shanghai:/usr/share/zoneinfo/Asia/Shanghai:ro
    environment:
      - ENABLE_DEBUG=debug
      - MIN_MEM=128m
      - MAX_MEM=1024m
      - ENABLE_JMX=
      - NACOS_HOST=$NACOS_HOST
      - NACOS_PORT=$NACOS_PORT
      - SENTINEL_HOST=$SENTINEL_HOST
      - SENTINEL_PORT=$SENTINEL_PORT
      - ZIPKIN_HOST=$ZIPKIN_HOST
      - ZIPKIN_PORT=$ZIPKIN_PORT
      - REDIS_HOST=$REDIS_HOST
      - REDIS_PORT=$REDIS_PORT
      - RABBITMQ_HOST=$RABBITMQ_HOST
      - RABBITMQ_PORT=$RABBITMQ_PORT
      - RABBITMQ_USERNAME=$RABBITMQ_USERNAME
      - RABBITMQ_PASSWORD=$RABBITMQ_PASSWORD
      - MYSQL_HOST=$MYSQL_HOST
      - MYSQL_PORT=$MYSQL_PORT
      - MYSQL_USERNAME=$MYSQL_USERNAME
      - MYSQL_PASSWORD=$MYSQL_PASSWORD
      - PUBLIC_HOST=$PUBLIC_HOST
      - POSTE_HOST=$POSTE_HOST
      - POSTE_SMTP_PORT=$POSTE_SMTP_PORT
      - SENTINEL_CLIENT_HOST=$SENTINEL_CLIENT_HOST
      - WS_HOST=$WS_HOST
      - WS_PORT=$WS_PORT
      - WSS_HOST=$WSS_HOST
      - WSS_PORT=$WSS_PORT
networks:
  default:
    external:
      name: docker_default
```
使用docker-compose定义docker镜像启动参数。其中networks定义docker_default，类似`$NACOS_HOST`的变量值在../../set-env.sh中定义，使用EXPORT导出。

### 疑难问题备录

1. docker推送可以通过打tag方式指定远程仓库，而非通过docker login.
2. 启动docker镜像时需要配置网络相关设置。可以通过``docker inspect 88453d3cc802``查看指定容器
```
    ...
    "Networks": {
                "docker_default": {
                    "IPAMConfig": {
                        "IPv4Address": "172.18.0.15"
                    },
                    "Links": null,
                    "Aliases": null,
                    "MacAddress": "02:42:ac:12:00:0f",
                    "NetworkID": "3adcf12d4f4f94bc1c8062256542ca71aea355e2860b84e106c7992dce5e754d",
                    "EndpointID": "f26a107495018c9212065327955e5fc5cec99957e558984d0529bfc0c93c356c",
                    "Gateway": "172.18.0.1",
                    "IPAddress": "172.18.0.15",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "DriverOpts": null,
                    "DNSNames": [
                        "hm_iui",
                        "88453d3cc802"
                    ]
                }
            }
    ...

```
    